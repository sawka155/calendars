{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseToDateTime = exports.LuxonHelper = void 0;\n\nconst luxon_1 = require(\"luxon\");\n\nconst constants_1 = require(\"../constants\");\n\nexports.LuxonHelper = {\n  isSameDay: (dateA, dateB) => {\n    return dateA.year === dateB.year && dateA.month === dateB.month && dateA.day === dateB.day;\n  },\n  differenceInDays: (start, end) => {\n    const diffInDaysObj = end.diff(start, 'hours').toObject();\n    const diffInHours = diffInDaysObj.hours;\n\n    if (diffInHours) {\n      return diffInHours <= 24 ? 1 : Number((diffInHours / 24).toFixed(0));\n    }\n\n    return 0;\n  }\n};\n\nconst parseToDateTime = ( // @ts-ignore\ndate, zone, deviceTimezone // @ts-ignore\n) => {\n  const dateString = typeof date === 'string' ? date : date.toString();\n  const isFloatingDatetime = zone === constants_1.FLOATING_DATETIME; // Adjust date with timezone so when converted to UTC it represents correct value with fixed time\n\n  if (isFloatingDatetime) {\n    // @ts-ignore\n    const dateFloating = luxon_1.DateTime.fromISO(dateString, {\n      zone: constants_1.UTC_TIMEZONE\n    });\n    return dateFloating.toUTC();\n  } // @ts-ignore\n\n\n  const thisDate = luxon_1.DateTime.fromISO(dateString);\n\n  if (!zone) {\n    // Adjust datetime to device timezone\n    if (deviceTimezone) {\n      return thisDate.setZone(deviceTimezone);\n    } else {\n      return thisDate;\n    }\n  }\n\n  return thisDate.setZone(zone);\n};\n\nexports.parseToDateTime = parseToDateTime;","map":{"version":3,"sources":["C:/Users/deval/Desktop/JSX/calendar2.0/node_modules/kalend-layout/utils/LuxonHelper.js"],"names":["Object","defineProperty","exports","value","parseToDateTime","LuxonHelper","luxon_1","require","constants_1","isSameDay","dateA","dateB","year","month","day","differenceInDays","start","end","diffInDaysObj","diff","toObject","diffInHours","hours","Number","toFixed","date","zone","deviceTimezone","dateString","toString","isFloatingDatetime","FLOATING_DATETIME","dateFloating","DateTime","fromISO","UTC_TIMEZONE","toUTC","thisDate","setZone"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0BF,OAAO,CAACG,WAAR,GAAsB,KAAK,CAArD;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AACAL,OAAO,CAACG,WAAR,GAAsB;AAClBI,EAAAA,SAAS,EAAE,CAACC,KAAD,EAAQC,KAAR,KAAkB;AACzB,WAAQD,KAAK,CAACE,IAAN,KAAeD,KAAK,CAACC,IAArB,IACJF,KAAK,CAACG,KAAN,KAAgBF,KAAK,CAACE,KADlB,IAEJH,KAAK,CAACI,GAAN,KAAcH,KAAK,CAACG,GAFxB;AAGH,GALiB;AAMlBC,EAAAA,gBAAgB,EAAE,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAC9B,UAAMC,aAAa,GAAGD,GAAG,CACpBE,IADiB,CACZH,KADY,EACL,OADK,EAEjBI,QAFiB,EAAtB;AAGA,UAAMC,WAAW,GAAGH,aAAa,CAACI,KAAlC;;AACA,QAAID,WAAJ,EAAiB;AACb,aAAOA,WAAW,IAAI,EAAf,GAAoB,CAApB,GAAwBE,MAAM,CAAC,CAACF,WAAW,GAAG,EAAf,EAAmBG,OAAnB,CAA2B,CAA3B,CAAD,CAArC;AACH;;AACD,WAAO,CAAP;AACH;AAfiB,CAAtB;;AAiBA,MAAMpB,eAAe,GAAG,EACxB;AACAqB,IAFwB,EAElBC,IAFkB,EAEZC,cAFY,CAGxB;AAHwB,KAInB;AACD,QAAMC,UAAU,GAAG,OAAOH,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCA,IAAI,CAACI,QAAL,EAArD;AACA,QAAMC,kBAAkB,GAAGJ,IAAI,KAAKlB,WAAW,CAACuB,iBAAhD,CAFC,CAGD;;AACA,MAAID,kBAAJ,EAAwB;AACpB;AACA,UAAME,YAAY,GAAG1B,OAAO,CAAC2B,QAAR,CAAiBC,OAAjB,CAAyBN,UAAzB,EAAqC;AACtDF,MAAAA,IAAI,EAAElB,WAAW,CAAC2B;AADoC,KAArC,CAArB;AAGA,WAAOH,YAAY,CAACI,KAAb,EAAP;AACH,GAVA,CAWD;;;AACA,QAAMC,QAAQ,GAAG/B,OAAO,CAAC2B,QAAR,CAAiBC,OAAjB,CAAyBN,UAAzB,CAAjB;;AACA,MAAI,CAACF,IAAL,EAAW;AACP;AACA,QAAIC,cAAJ,EAAoB;AAChB,aAAOU,QAAQ,CAACC,OAAT,CAAiBX,cAAjB,CAAP;AACH,KAFD,MAGK;AACD,aAAOU,QAAP;AACH;AACJ;;AACD,SAAOA,QAAQ,CAACC,OAAT,CAAiBZ,IAAjB,CAAP;AACH,CA3BD;;AA4BAxB,OAAO,CAACE,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseToDateTime = exports.LuxonHelper = void 0;\nconst luxon_1 = require(\"luxon\");\nconst constants_1 = require(\"../constants\");\nexports.LuxonHelper = {\n    isSameDay: (dateA, dateB) => {\n        return (dateA.year === dateB.year &&\n            dateA.month === dateB.month &&\n            dateA.day === dateB.day);\n    },\n    differenceInDays: (start, end) => {\n        const diffInDaysObj = end\n            .diff(start, 'hours')\n            .toObject();\n        const diffInHours = diffInDaysObj.hours;\n        if (diffInHours) {\n            return diffInHours <= 24 ? 1 : Number((diffInHours / 24).toFixed(0));\n        }\n        return 0;\n    },\n};\nconst parseToDateTime = (\n// @ts-ignore\ndate, zone, deviceTimezone\n// @ts-ignore\n) => {\n    const dateString = typeof date === 'string' ? date : date.toString();\n    const isFloatingDatetime = zone === constants_1.FLOATING_DATETIME;\n    // Adjust date with timezone so when converted to UTC it represents correct value with fixed time\n    if (isFloatingDatetime) {\n        // @ts-ignore\n        const dateFloating = luxon_1.DateTime.fromISO(dateString, {\n            zone: constants_1.UTC_TIMEZONE,\n        });\n        return dateFloating.toUTC();\n    }\n    // @ts-ignore\n    const thisDate = luxon_1.DateTime.fromISO(dateString);\n    if (!zone) {\n        // Adjust datetime to device timezone\n        if (deviceTimezone) {\n            return thisDate.setZone(deviceTimezone);\n        }\n        else {\n            return thisDate;\n        }\n    }\n    return thisDate.setZone(zone);\n};\nexports.parseToDateTime = parseToDateTime;\n"]},"metadata":{},"sourceType":"script"}