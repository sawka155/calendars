{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMonthViewLayout = exports.prepareMultiDayEvents = void 0;\n\nconst index_1 = require(\"../index\");\n\nconst commonHelper_1 = require(\"../utils/commonHelper\");\n\nconst LuxonHelper_1 = require(\"../utils/LuxonHelper\");\n\nconst Helper_1 = require(\"../utils/Helper\");\n\nconst KalendHelper_1 = require(\"../utils/KalendHelper\");\n\nconst monthViewHelper_1 = require(\"../utils/monthViewHelper\");\n\nconst prepareMultiDayEvents = (events, config, breakPointDate) => {\n  const preparedEvents = {};\n  events.forEach(event => {\n    const {\n      dateTimeStart,\n      dateTimeEnd\n    } = KalendHelper_1.getEventDateTime(event, config); // check if is multi-day\n\n    const isSameDay = LuxonHelper_1.LuxonHelper.isSameDay(dateTimeStart, dateTimeEnd); // origin date to determine when event starts in each row\n\n    let originDate = Helper_1.formatToDateKey(dateTimeStart); // handle multi-day\n\n    if (!isSameDay) {\n      const diffInDays = LuxonHelper_1.LuxonHelper.differenceInDays(dateTimeStart, dateTimeEnd); // need to store each occurrence\n\n      let daySpawns = []; // flag if events continue in next row\n      // split daySpawns and adjust originDate\n\n      for (let i = 0; i <= diffInDays; i++) {\n        const refDate = dateTimeStart.plus({\n          days: i\n        });\n        const dateKey = Helper_1.formatToDateKey(refDate, config.timezone); // store each day in multi-day event range\n\n        daySpawns.push(dateKey); // break events spawned across multiple rows\n\n        const dateOfWeek = refDate.weekday;\n        const weekDayBreakPoint = config.weekDayStart === index_1.WEEKDAY_START.MONDAY ? 7 : 1;\n\n        if (dateOfWeek === weekDayBreakPoint || i === diffInDays) {\n          const eventClone = Object.assign(Object.assign({}, event), {\n            originDate,\n            daysAfter: diffInDays - i\n          });\n          eventClone.daySpawns = daySpawns;\n\n          if (!preparedEvents[originDate]) {\n            preparedEvents[originDate] = [eventClone];\n          } else {\n            preparedEvents[originDate] = [...preparedEvents[originDate], ...[eventClone]];\n          }\n\n          daySpawns = [];\n        }\n\n        if ((breakPointDate && breakPointDate === dateKey || dateOfWeek === weekDayBreakPoint) && i < diffInDays) {\n          originDate = Helper_1.formatToDateKey(refDate.plus({\n            days: 1\n          }));\n        }\n      }\n    } else {\n      // single day event\n      const dateKey = Helper_1.formatToDateKey(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt || config.timezone));\n      event.originDate = originDate;\n\n      if (!preparedEvents[dateKey]) {\n        preparedEvents[dateKey] = [event];\n      } else {\n        preparedEvents[dateKey] = [...preparedEvents[dateKey], ...[event]];\n      }\n    }\n  });\n  return preparedEvents;\n};\n\nexports.prepareMultiDayEvents = prepareMultiDayEvents;\n\nconst getMonthViewLayout = (events, width, calendarDays, config, maxEventsVisible, isHeaderEvents) => {\n  const result = []; // split calendar days to rows\n\n  const calendarDaysRows = monthViewHelper_1.getMonthRows(calendarDays); // Group all events by date key\n  // Clone multi-day events to all dates in its range (start from first\n  // calendar day and end in last calendar day\n\n  if (!events) {\n    return commonHelper_1.DEFAULT_ROW_LAYOUT_RESULT;\n  }\n\n  const preparedEvents = exports.prepareMultiDayEvents(events, config); // store max offset top to adjust height of header events parent element\n\n  let headerOffsetTop = 0;\n  let overflowingEvents = {}; // get layout for each row\n\n  calendarDaysRows.forEach(row => {\n    const rowResult = commonHelper_1.getRowLayout(preparedEvents, width / 7, row, config.timezone, maxEventsVisible, isHeaderEvents, overflowingEvents); // store only max value\n\n    if (rowResult.headerOffsetTop > headerOffsetTop) {\n      headerOffsetTop = rowResult.headerOffsetTop;\n    }\n\n    result.push(rowResult.positions);\n    overflowingEvents = rowResult.overflowingEvents;\n  });\n  return {\n    positions: result,\n    overflowingEvents,\n    headerOffsetTop\n  };\n};\n\nexports.getMonthViewLayout = getMonthViewLayout;","map":{"version":3,"sources":["C:/Users/deval/Desktop/JSX/calendar2.0/node_modules/kalend-layout/views/monthView.js"],"names":["Object","defineProperty","exports","value","getMonthViewLayout","prepareMultiDayEvents","index_1","require","commonHelper_1","LuxonHelper_1","Helper_1","KalendHelper_1","monthViewHelper_1","events","config","breakPointDate","preparedEvents","forEach","event","dateTimeStart","dateTimeEnd","getEventDateTime","isSameDay","LuxonHelper","originDate","formatToDateKey","diffInDays","differenceInDays","daySpawns","i","refDate","plus","days","dateKey","timezone","push","dateOfWeek","weekday","weekDayBreakPoint","weekDayStart","WEEKDAY_START","MONDAY","eventClone","assign","daysAfter","parseToDateTime","startAt","timezoneStartAt","width","calendarDays","maxEventsVisible","isHeaderEvents","result","calendarDaysRows","getMonthRows","DEFAULT_ROW_LAYOUT_RESULT","headerOffsetTop","overflowingEvents","row","rowResult","getRowLayout","positions"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kBAAR,GAA6BF,OAAO,CAACG,qBAAR,GAAgC,KAAK,CAAlE;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,sBAAD,CAA7B;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,iBAAD,CAAxB;;AACA,MAAMI,cAAc,GAAGJ,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAMK,iBAAiB,GAAGL,OAAO,CAAC,0BAAD,CAAjC;;AACA,MAAMF,qBAAqB,GAAG,CAACQ,MAAD,EAASC,MAAT,EAAiBC,cAAjB,KAAoC;AAC9D,QAAMC,cAAc,GAAG,EAAvB;AACAH,EAAAA,MAAM,CAACI,OAAP,CAAgBC,KAAD,IAAW;AACtB,UAAM;AAAEC,MAAAA,aAAF;AAAiBC,MAAAA;AAAjB,QAAiCT,cAAc,CAACU,gBAAf,CAAgCH,KAAhC,EAAuCJ,MAAvC,CAAvC,CADsB,CAEtB;;AACA,UAAMQ,SAAS,GAAGb,aAAa,CAACc,WAAd,CAA0BD,SAA1B,CAAoCH,aAApC,EAAmDC,WAAnD,CAAlB,CAHsB,CAItB;;AACA,QAAII,UAAU,GAAGd,QAAQ,CAACe,eAAT,CAAyBN,aAAzB,CAAjB,CALsB,CAMtB;;AACA,QAAI,CAACG,SAAL,EAAgB;AACZ,YAAMI,UAAU,GAAGjB,aAAa,CAACc,WAAd,CAA0BI,gBAA1B,CAA2CR,aAA3C,EAA0DC,WAA1D,CAAnB,CADY,CAEZ;;AACA,UAAIQ,SAAS,GAAG,EAAhB,CAHY,CAIZ;AACA;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,UAArB,EAAiCG,CAAC,EAAlC,EAAsC;AAClC,cAAMC,OAAO,GAAGX,aAAa,CAACY,IAAd,CAAmB;AAAEC,UAAAA,IAAI,EAAEH;AAAR,SAAnB,CAAhB;AACA,cAAMI,OAAO,GAAGvB,QAAQ,CAACe,eAAT,CAAyBK,OAAzB,EAAkChB,MAAM,CAACoB,QAAzC,CAAhB,CAFkC,CAGlC;;AACAN,QAAAA,SAAS,CAACO,IAAV,CAAeF,OAAf,EAJkC,CAKlC;;AACA,cAAMG,UAAU,GAAGN,OAAO,CAACO,OAA3B;AACA,cAAMC,iBAAiB,GAAGxB,MAAM,CAACyB,YAAP,KAAwBjC,OAAO,CAACkC,aAAR,CAAsBC,MAA9C,GAAuD,CAAvD,GAA2D,CAArF;;AACA,YAAIL,UAAU,KAAKE,iBAAf,IAAoCT,CAAC,KAAKH,UAA9C,EAA0D;AACtD,gBAAMgB,UAAU,GAAG1C,MAAM,CAAC2C,MAAP,CAAc3C,MAAM,CAAC2C,MAAP,CAAc,EAAd,EAAkBzB,KAAlB,CAAd,EAAwC;AAAEM,YAAAA,UAAF;AAAcoB,YAAAA,SAAS,EAAElB,UAAU,GAAGG;AAAtC,WAAxC,CAAnB;AACAa,UAAAA,UAAU,CAACd,SAAX,GAAuBA,SAAvB;;AACA,cAAI,CAACZ,cAAc,CAACQ,UAAD,CAAnB,EAAiC;AAC7BR,YAAAA,cAAc,CAACQ,UAAD,CAAd,GAA6B,CAACkB,UAAD,CAA7B;AACH,WAFD,MAGK;AACD1B,YAAAA,cAAc,CAACQ,UAAD,CAAd,GAA6B,CACzB,GAAGR,cAAc,CAACQ,UAAD,CADQ,EAEzB,GAAG,CAACkB,UAAD,CAFsB,CAA7B;AAIH;;AACDd,UAAAA,SAAS,GAAG,EAAZ;AACH;;AACD,YAAI,CAAEb,cAAc,IAAIA,cAAc,KAAKkB,OAAtC,IACDG,UAAU,KAAKE,iBADf,KAEAT,CAAC,GAAGH,UAFR,EAEoB;AAChBF,UAAAA,UAAU,GAAGd,QAAQ,CAACe,eAAT,CAAyBK,OAAO,CAACC,IAAR,CAAa;AAAEC,YAAAA,IAAI,EAAE;AAAR,WAAb,CAAzB,CAAb;AACH;AACJ;AACJ,KAlCD,MAmCK;AACD;AACA,YAAMC,OAAO,GAAGvB,QAAQ,CAACe,eAAT,CAAyBhB,aAAa,CAACoC,eAAd,CAA8B3B,KAAK,CAAC4B,OAApC,EAA6C5B,KAAK,CAAC6B,eAAN,IAAyBjC,MAAM,CAACoB,QAA7E,CAAzB,CAAhB;AACAhB,MAAAA,KAAK,CAACM,UAAN,GAAmBA,UAAnB;;AACA,UAAI,CAACR,cAAc,CAACiB,OAAD,CAAnB,EAA8B;AAC1BjB,QAAAA,cAAc,CAACiB,OAAD,CAAd,GAA0B,CAACf,KAAD,CAA1B;AACH,OAFD,MAGK;AACDF,QAAAA,cAAc,CAACiB,OAAD,CAAd,GAA0B,CAAC,GAAGjB,cAAc,CAACiB,OAAD,CAAlB,EAA6B,GAAG,CAACf,KAAD,CAAhC,CAA1B;AACH;AACJ;AACJ,GArDD;AAsDA,SAAOF,cAAP;AACH,CAzDD;;AA0DAd,OAAO,CAACG,qBAAR,GAAgCA,qBAAhC;;AACA,MAAMD,kBAAkB,GAAG,CAACS,MAAD,EAASmC,KAAT,EAAgBC,YAAhB,EAA8BnC,MAA9B,EAAsCoC,gBAAtC,EAAwDC,cAAxD,KAA2E;AAClG,QAAMC,MAAM,GAAG,EAAf,CADkG,CAElG;;AACA,QAAMC,gBAAgB,GAAGzC,iBAAiB,CAAC0C,YAAlB,CAA+BL,YAA/B,CAAzB,CAHkG,CAIlG;AACA;AACA;;AACA,MAAI,CAACpC,MAAL,EAAa;AACT,WAAOL,cAAc,CAAC+C,yBAAtB;AACH;;AACD,QAAMvC,cAAc,GAAGd,OAAO,CAACG,qBAAR,CAA8BQ,MAA9B,EAAsCC,MAAtC,CAAvB,CAVkG,CAWlG;;AACA,MAAI0C,eAAe,GAAG,CAAtB;AACA,MAAIC,iBAAiB,GAAG,EAAxB,CAbkG,CAclG;;AACAJ,EAAAA,gBAAgB,CAACpC,OAAjB,CAA0ByC,GAAD,IAAS;AAC9B,UAAMC,SAAS,GAAGnD,cAAc,CAACoD,YAAf,CAA4B5C,cAA5B,EAA4CgC,KAAK,GAAG,CAApD,EAAuDU,GAAvD,EAA4D5C,MAAM,CAACoB,QAAnE,EAA6EgB,gBAA7E,EAA+FC,cAA/F,EAA+GM,iBAA/G,CAAlB,CAD8B,CAE9B;;AACA,QAAIE,SAAS,CAACH,eAAV,GAA4BA,eAAhC,EAAiD;AAC7CA,MAAAA,eAAe,GAAGG,SAAS,CAACH,eAA5B;AACH;;AACDJ,IAAAA,MAAM,CAACjB,IAAP,CAAYwB,SAAS,CAACE,SAAtB;AACAJ,IAAAA,iBAAiB,GAAGE,SAAS,CAACF,iBAA9B;AACH,GARD;AASA,SAAO;AACHI,IAAAA,SAAS,EAAET,MADR;AAEHK,IAAAA,iBAFG;AAGHD,IAAAA;AAHG,GAAP;AAKH,CA7BD;;AA8BAtD,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getMonthViewLayout = exports.prepareMultiDayEvents = void 0;\nconst index_1 = require(\"../index\");\nconst commonHelper_1 = require(\"../utils/commonHelper\");\nconst LuxonHelper_1 = require(\"../utils/LuxonHelper\");\nconst Helper_1 = require(\"../utils/Helper\");\nconst KalendHelper_1 = require(\"../utils/KalendHelper\");\nconst monthViewHelper_1 = require(\"../utils/monthViewHelper\");\nconst prepareMultiDayEvents = (events, config, breakPointDate) => {\n    const preparedEvents = {};\n    events.forEach((event) => {\n        const { dateTimeStart, dateTimeEnd } = KalendHelper_1.getEventDateTime(event, config);\n        // check if is multi-day\n        const isSameDay = LuxonHelper_1.LuxonHelper.isSameDay(dateTimeStart, dateTimeEnd);\n        // origin date to determine when event starts in each row\n        let originDate = Helper_1.formatToDateKey(dateTimeStart);\n        // handle multi-day\n        if (!isSameDay) {\n            const diffInDays = LuxonHelper_1.LuxonHelper.differenceInDays(dateTimeStart, dateTimeEnd);\n            // need to store each occurrence\n            let daySpawns = [];\n            // flag if events continue in next row\n            // split daySpawns and adjust originDate\n            for (let i = 0; i <= diffInDays; i++) {\n                const refDate = dateTimeStart.plus({ days: i });\n                const dateKey = Helper_1.formatToDateKey(refDate, config.timezone);\n                // store each day in multi-day event range\n                daySpawns.push(dateKey);\n                // break events spawned across multiple rows\n                const dateOfWeek = refDate.weekday;\n                const weekDayBreakPoint = config.weekDayStart === index_1.WEEKDAY_START.MONDAY ? 7 : 1;\n                if (dateOfWeek === weekDayBreakPoint || i === diffInDays) {\n                    const eventClone = Object.assign(Object.assign({}, event), { originDate, daysAfter: diffInDays - i });\n                    eventClone.daySpawns = daySpawns;\n                    if (!preparedEvents[originDate]) {\n                        preparedEvents[originDate] = [eventClone];\n                    }\n                    else {\n                        preparedEvents[originDate] = [\n                            ...preparedEvents[originDate],\n                            ...[eventClone],\n                        ];\n                    }\n                    daySpawns = [];\n                }\n                if (((breakPointDate && breakPointDate === dateKey) ||\n                    dateOfWeek === weekDayBreakPoint) &&\n                    i < diffInDays) {\n                    originDate = Helper_1.formatToDateKey(refDate.plus({ days: 1 }));\n                }\n            }\n        }\n        else {\n            // single day event\n            const dateKey = Helper_1.formatToDateKey(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt || config.timezone));\n            event.originDate = originDate;\n            if (!preparedEvents[dateKey]) {\n                preparedEvents[dateKey] = [event];\n            }\n            else {\n                preparedEvents[dateKey] = [...preparedEvents[dateKey], ...[event]];\n            }\n        }\n    });\n    return preparedEvents;\n};\nexports.prepareMultiDayEvents = prepareMultiDayEvents;\nconst getMonthViewLayout = (events, width, calendarDays, config, maxEventsVisible, isHeaderEvents) => {\n    const result = [];\n    // split calendar days to rows\n    const calendarDaysRows = monthViewHelper_1.getMonthRows(calendarDays);\n    // Group all events by date key\n    // Clone multi-day events to all dates in its range (start from first\n    // calendar day and end in last calendar day\n    if (!events) {\n        return commonHelper_1.DEFAULT_ROW_LAYOUT_RESULT;\n    }\n    const preparedEvents = exports.prepareMultiDayEvents(events, config);\n    // store max offset top to adjust height of header events parent element\n    let headerOffsetTop = 0;\n    let overflowingEvents = {};\n    // get layout for each row\n    calendarDaysRows.forEach((row) => {\n        const rowResult = commonHelper_1.getRowLayout(preparedEvents, width / 7, row, config.timezone, maxEventsVisible, isHeaderEvents, overflowingEvents);\n        // store only max value\n        if (rowResult.headerOffsetTop > headerOffsetTop) {\n            headerOffsetTop = rowResult.headerOffsetTop;\n        }\n        result.push(rowResult.positions);\n        overflowingEvents = rowResult.overflowingEvents;\n    });\n    return {\n        positions: result,\n        overflowingEvents,\n        headerOffsetTop,\n    };\n};\nexports.getMonthViewLayout = getMonthViewLayout;\n"]},"metadata":{},"sourceType":"script"}