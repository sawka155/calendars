{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkIfIsDaysView = exports.getRowLayout = exports.DEFAULT_ROW_LAYOUT_RESULT = void 0;\n\nconst index_1 = require(\"../index\");\n\nconst constants_1 = require(\"../constants\");\n\nconst Helper_1 = require(\"./Helper\");\n/**\n * Find free slot in day column where to put event\n * @param indexes\n * @param maxEventsVisible\n */\n\n\nconst findFreeSlot = (indexes, maxEventsVisible) => {\n  let freeIndex;\n\n  if (!maxEventsVisible || maxEventsVisible <= 0) {\n    return -999;\n  }\n\n  for (let i = 0; i < maxEventsVisible + 1; i++) {\n    if (indexes.length === 0 || !indexes.includes(i)) {\n      freeIndex = i;\n      return freeIndex;\n    }\n  }\n\n  return -1;\n};\n\nconst addEventToResult = (usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents) => {\n  usedIDs.push(`${event.id}_${event.internalID}`);\n\n  if (event.daySpawns) {\n    event.daySpawns.forEach(daySpawn => {\n      if (takenIndexes[daySpawn]) {\n        takenIndexes[daySpawn] = [...takenIndexes[daySpawn], ...[offsetTopIndex]];\n      } else {\n        takenIndexes[daySpawn] = [offsetTopIndex];\n      }\n    });\n  } else {\n    if (takenIndexes[event.originDate]) {\n      takenIndexes[event.originDate] = [...takenIndexes[event.originDate], ...[offsetTopIndex]];\n    } else {\n      takenIndexes[event.originDate] = [offsetTopIndex];\n    }\n  } // spawn width across all days\n\n\n  const eventWidth = event.daySpawns ? width * event.daySpawns.length : width;\n  const eventOffsetTop = 20 * offsetTopIndex;\n\n  if (isHeaderEvents && eventOffsetTop > headerOffsetTop) {\n    headerOffsetTop = eventOffsetTop;\n  }\n\n  const data = {\n    event,\n    width: Math.round(eventWidth - tableSpace),\n    offsetLeft: dayIndex * width + 2,\n    offsetTop: constants_1.getEventHeight(isHeaderEvents) * offsetTopIndex + offsetTopIndex,\n    height: constants_1.getEventHeight(isHeaderEvents),\n    zIndex: 2\n  };\n  result.push(data);\n  return {\n    headerOffsetTop,\n    takenIndexes\n  };\n};\n\nexports.DEFAULT_ROW_LAYOUT_RESULT = {\n  positions: [],\n  overflowingEvents: [],\n  headerOffsetTop: 0\n};\n\nconst addToOverflowingEvents = (event, date, overflowingEvents) => {\n  if (overflowingEvents[date]) {\n    overflowingEvents[date] = [...overflowingEvents[date], event];\n  } else {\n    overflowingEvents[date] = [event];\n  }\n};\n/**\n * Use for month view and header events\n * @param events\n * @param width\n * @param calendarDays\n * @param timezone\n * @param maxEventsVisible\n * @param isHeaderEvents\n * @param overflowingEvents\n */\n\n\nconst getRowLayout = (events, width, calendarDays, timezone, maxEventsVisible, isHeaderEvents, overflowingEvents) => {\n  // store biggest offset top for day view header events\n  let headerOffsetTop = 0;\n  const tableSpace = width / 100 * constants_1.EVENT_TABLE_DELIMITER_SPACE;\n  const result = [];\n\n  if (!events) {\n    return exports.DEFAULT_ROW_LAYOUT_RESULT;\n  } // prevent adding duplicates from multi-day clones\n\n\n  const usedIDs = []; // store taken indexes under date key\n\n  let takenIndexes = {};\n  const calendarDaysDateKey = calendarDays.map(day => Helper_1.formatToDateKey(day, timezone));\n  calendarDays.forEach((day, dayIndex) => {\n    const dateKey = Helper_1.formatToDateKey(day, timezone); // get only events for this day\n\n    const dayEvents = events[dateKey];\n    let eventRealIndex = 0; // use basic index for events with free slots\n\n    if (dayEvents) {\n      dayEvents.forEach(event => {\n        const takenSlots = takenIndexes[event.originDate]; // find free slot\n\n        let offsetTopIndex = takenSlots ? findFreeSlot(takenSlots, maxEventsVisible) : eventRealIndex;\n\n        if (!usedIDs.includes(event.id)) {\n          //\n          if (!maxEventsVisible || maxEventsVisible <= 0 || eventRealIndex >= maxEventsVisible || offsetTopIndex >= maxEventsVisible) {\n            offsetTopIndex = -999;\n          }\n\n          eventRealIndex += 1; // check for overflowing events\n\n          if (offsetTopIndex === -1 && overflowingEvents) {\n            // save all clones to overflown array\n            if (event.daySpawns) {\n              event.daySpawns.forEach(daySpawn => {\n                var _a, _b; // check if we can fit spawn to column\n\n\n                const takenSlotsSpawn = takenIndexes[daySpawn]; // find free slot\n\n                offsetTopIndex = takenSlotsSpawn ? findFreeSlot(takenSlotsSpawn, maxEventsVisible) : 0; // we can use 0 top index as either next day wasn't\n                // iterated yet or takenSlotsSpawn exists for that column\n\n                if (offsetTopIndex <= -1 && overflowingEvents) {\n                  addToOverflowingEvents(event, daySpawn, overflowingEvents);\n                } else {\n                  const eventAddResult = addEventToResult(usedIDs, Object.assign(Object.assign({}, event), {\n                    originDate: daySpawn,\n                    daySpawns: (_a = event.daySpawns) === null || _a === void 0 ? void 0 : _a.slice((_b = event.daySpawns) === null || _b === void 0 ? void 0 : _b.indexOf(daySpawn))\n                  }), takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, // adjust date index for daySpawn\n                  calendarDaysDateKey.indexOf(daySpawn), result, isHeaderEvents);\n                  headerOffsetTop = eventAddResult.headerOffsetTop;\n                  takenIndexes = eventAddResult.takenIndexes;\n                }\n              });\n            } else {\n              addToOverflowingEvents(event, event.originDate, overflowingEvents);\n            }\n          } else if (offsetTopIndex === -999) {\n            if (event.daySpawns) {\n              event.daySpawns.forEach(daySpawn => {\n                addToOverflowingEvents(event, daySpawn, overflowingEvents);\n              });\n            } else {\n              addToOverflowingEvents(event, event.originDate, overflowingEvents);\n            }\n          } else {\n            const eventAddResult = addEventToResult(usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents);\n            headerOffsetTop = eventAddResult.headerOffsetTop;\n            takenIndexes = eventAddResult.takenIndexes;\n          }\n        }\n      });\n    }\n  });\n  return {\n    positions: result,\n    overflowingEvents,\n    headerOffsetTop\n  };\n};\n\nexports.getRowLayout = getRowLayout;\n\nconst checkIfIsDaysView = view => {\n  return view === index_1.CALENDAR_VIEW.WEEK || view === index_1.CALENDAR_VIEW.DAY || view === index_1.CALENDAR_VIEW.THREE_DAYS;\n};\n\nexports.checkIfIsDaysView = checkIfIsDaysView;","map":{"version":3,"sources":["C:/Users/deval/Desktop/JSX/calendar2.0/node_modules/kalend-layout/utils/commonHelper.js"],"names":["Object","defineProperty","exports","value","checkIfIsDaysView","getRowLayout","DEFAULT_ROW_LAYOUT_RESULT","index_1","require","constants_1","Helper_1","findFreeSlot","indexes","maxEventsVisible","freeIndex","i","length","includes","addEventToResult","usedIDs","event","takenIndexes","offsetTopIndex","width","headerOffsetTop","tableSpace","dayIndex","result","isHeaderEvents","push","id","internalID","daySpawns","forEach","daySpawn","originDate","eventWidth","eventOffsetTop","data","Math","round","offsetLeft","offsetTop","getEventHeight","height","zIndex","positions","overflowingEvents","addToOverflowingEvents","date","events","calendarDays","timezone","EVENT_TABLE_DELIMITER_SPACE","calendarDaysDateKey","map","day","formatToDateKey","dateKey","dayEvents","eventRealIndex","takenSlots","_a","_b","takenSlotsSpawn","eventAddResult","assign","slice","indexOf","view","CALENDAR_VIEW","WEEK","DAY","THREE_DAYS"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,iBAAR,GAA4BF,OAAO,CAACG,YAAR,GAAuBH,OAAO,CAACI,yBAAR,GAAoC,KAAK,CAA5F;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,UAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,YAAY,GAAG,CAACC,OAAD,EAAUC,gBAAV,KAA+B;AAChD,MAAIC,SAAJ;;AACA,MAAI,CAACD,gBAAD,IAAqBA,gBAAgB,IAAI,CAA7C,EAAgD;AAC5C,WAAO,CAAC,GAAR;AACH;;AACD,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAAgB,GAAG,CAAvC,EAA0CE,CAAC,EAA3C,EAA+C;AAC3C,QAAIH,OAAO,CAACI,MAAR,KAAmB,CAAnB,IAAwB,CAACJ,OAAO,CAACK,QAAR,CAAiBF,CAAjB,CAA7B,EAAkD;AAC9CD,MAAAA,SAAS,GAAGC,CAAZ;AACA,aAAOD,SAAP;AACH;AACJ;;AACD,SAAO,CAAC,CAAR;AACH,CAZD;;AAaA,MAAMI,gBAAgB,GAAG,CAACC,OAAD,EAAUC,KAAV,EAAiBC,YAAjB,EAA+BC,cAA/B,EAA+CC,KAA/C,EAAsDC,eAAtD,EAAuEC,UAAvE,EAAmFC,QAAnF,EAA6FC,MAA7F,EAAqGC,cAArG,KAAwH;AAC7IT,EAAAA,OAAO,CAACU,IAAR,CAAc,GAAET,KAAK,CAACU,EAAG,IAAGV,KAAK,CAACW,UAAW,EAA7C;;AACA,MAAIX,KAAK,CAACY,SAAV,EAAqB;AACjBZ,IAAAA,KAAK,CAACY,SAAN,CAAgBC,OAAhB,CAAyBC,QAAD,IAAc;AAClC,UAAIb,YAAY,CAACa,QAAD,CAAhB,EAA4B;AACxBb,QAAAA,YAAY,CAACa,QAAD,CAAZ,GAAyB,CACrB,GAAGb,YAAY,CAACa,QAAD,CADM,EAErB,GAAG,CAACZ,cAAD,CAFkB,CAAzB;AAIH,OALD,MAMK;AACDD,QAAAA,YAAY,CAACa,QAAD,CAAZ,GAAyB,CAACZ,cAAD,CAAzB;AACH;AACJ,KAVD;AAWH,GAZD,MAaK;AACD,QAAID,YAAY,CAACD,KAAK,CAACe,UAAP,CAAhB,EAAoC;AAChCd,MAAAA,YAAY,CAACD,KAAK,CAACe,UAAP,CAAZ,GAAiC,CAC7B,GAAGd,YAAY,CAACD,KAAK,CAACe,UAAP,CADc,EAE7B,GAAG,CAACb,cAAD,CAF0B,CAAjC;AAIH,KALD,MAMK;AACDD,MAAAA,YAAY,CAACD,KAAK,CAACe,UAAP,CAAZ,GAAiC,CAACb,cAAD,CAAjC;AACH;AACJ,GAzB4I,CA0B7I;;;AACA,QAAMc,UAAU,GAAGhB,KAAK,CAACY,SAAN,GAAkBT,KAAK,GAAGH,KAAK,CAACY,SAAN,CAAgBhB,MAA1C,GAAmDO,KAAtE;AACA,QAAMc,cAAc,GAAG,KAAKf,cAA5B;;AACA,MAAIM,cAAc,IAAIS,cAAc,GAAGb,eAAvC,EAAwD;AACpDA,IAAAA,eAAe,GAAGa,cAAlB;AACH;;AACD,QAAMC,IAAI,GAAG;AACTlB,IAAAA,KADS;AAETG,IAAAA,KAAK,EAAEgB,IAAI,CAACC,KAAL,CAAWJ,UAAU,GAAGX,UAAxB,CAFE;AAGTgB,IAAAA,UAAU,EAAEf,QAAQ,GAAGH,KAAX,GAAmB,CAHtB;AAITmB,IAAAA,SAAS,EAAEjC,WAAW,CAACkC,cAAZ,CAA2Bf,cAA3B,IAA6CN,cAA7C,GAA8DA,cAJhE;AAKTsB,IAAAA,MAAM,EAAEnC,WAAW,CAACkC,cAAZ,CAA2Bf,cAA3B,CALC;AAMTiB,IAAAA,MAAM,EAAE;AANC,GAAb;AAQAlB,EAAAA,MAAM,CAACE,IAAP,CAAYS,IAAZ;AACA,SAAO;AACHd,IAAAA,eADG;AAEHH,IAAAA;AAFG,GAAP;AAIH,CA7CD;;AA8CAnB,OAAO,CAACI,yBAAR,GAAoC;AAChCwC,EAAAA,SAAS,EAAE,EADqB;AAEhCC,EAAAA,iBAAiB,EAAE,EAFa;AAGhCvB,EAAAA,eAAe,EAAE;AAHe,CAApC;;AAKA,MAAMwB,sBAAsB,GAAG,CAAC5B,KAAD,EAAQ6B,IAAR,EAAcF,iBAAd,KAAoC;AAC/D,MAAIA,iBAAiB,CAACE,IAAD,CAArB,EAA6B;AACzBF,IAAAA,iBAAiB,CAACE,IAAD,CAAjB,GAA0B,CAAC,GAAGF,iBAAiB,CAACE,IAAD,CAArB,EAA6B7B,KAA7B,CAA1B;AACH,GAFD,MAGK;AACD2B,IAAAA,iBAAiB,CAACE,IAAD,CAAjB,GAA0B,CAAC7B,KAAD,CAA1B;AACH;AACJ,CAPD;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMf,YAAY,GAAG,CAAC6C,MAAD,EAAS3B,KAAT,EAAgB4B,YAAhB,EAA8BC,QAA9B,EAAwCvC,gBAAxC,EAA0De,cAA1D,EAA0EmB,iBAA1E,KAAgG;AACjH;AACA,MAAIvB,eAAe,GAAG,CAAtB;AACA,QAAMC,UAAU,GAAIF,KAAK,GAAG,GAAT,GAAgBd,WAAW,CAAC4C,2BAA/C;AACA,QAAM1B,MAAM,GAAG,EAAf;;AACA,MAAI,CAACuB,MAAL,EAAa;AACT,WAAOhD,OAAO,CAACI,yBAAf;AACH,GAPgH,CAQjH;;;AACA,QAAMa,OAAO,GAAG,EAAhB,CATiH,CAUjH;;AACA,MAAIE,YAAY,GAAG,EAAnB;AACA,QAAMiC,mBAAmB,GAAGH,YAAY,CAACI,GAAb,CAAkBC,GAAD,IAAS9C,QAAQ,CAAC+C,eAAT,CAAyBD,GAAzB,EAA8BJ,QAA9B,CAA1B,CAA5B;AACAD,EAAAA,YAAY,CAAClB,OAAb,CAAqB,CAACuB,GAAD,EAAM9B,QAAN,KAAmB;AACpC,UAAMgC,OAAO,GAAGhD,QAAQ,CAAC+C,eAAT,CAAyBD,GAAzB,EAA8BJ,QAA9B,CAAhB,CADoC,CAEpC;;AACA,UAAMO,SAAS,GAAGT,MAAM,CAACQ,OAAD,CAAxB;AACA,QAAIE,cAAc,GAAG,CAArB,CAJoC,CAIZ;;AACxB,QAAID,SAAJ,EAAe;AACXA,MAAAA,SAAS,CAAC1B,OAAV,CAAmBb,KAAD,IAAW;AACzB,cAAMyC,UAAU,GAAGxC,YAAY,CAACD,KAAK,CAACe,UAAP,CAA/B,CADyB,CAEzB;;AACA,YAAIb,cAAc,GAAGuC,UAAU,GACzBlD,YAAY,CAACkD,UAAD,EAAahD,gBAAb,CADa,GAEzB+C,cAFN;;AAGA,YAAI,CAACzC,OAAO,CAACF,QAAR,CAAiBG,KAAK,CAACU,EAAvB,CAAL,EAAiC;AAC7B;AACA,cAAI,CAACjB,gBAAD,IACAA,gBAAgB,IAAI,CADpB,IAEA+C,cAAc,IAAI/C,gBAFlB,IAGAS,cAAc,IAAIT,gBAHtB,EAGwC;AACpCS,YAAAA,cAAc,GAAG,CAAC,GAAlB;AACH;;AACDsC,UAAAA,cAAc,IAAI,CAAlB,CAR6B,CAS7B;;AACA,cAAItC,cAAc,KAAK,CAAC,CAApB,IAAyByB,iBAA7B,EAAgD;AAC5C;AACA,gBAAI3B,KAAK,CAACY,SAAV,EAAqB;AACjBZ,cAAAA,KAAK,CAACY,SAAN,CAAgBC,OAAhB,CAAyBC,QAAD,IAAc;AAClC,oBAAI4B,EAAJ,EAAQC,EAAR,CADkC,CAElC;;;AACA,sBAAMC,eAAe,GAAG3C,YAAY,CAACa,QAAD,CAApC,CAHkC,CAIlC;;AACAZ,gBAAAA,cAAc,GAAG0C,eAAe,GAC1BrD,YAAY,CAACqD,eAAD,EAAkBnD,gBAAlB,CADc,GAE1B,CAFN,CALkC,CAOzB;AACT;;AACA,oBAAIS,cAAc,IAAI,CAAC,CAAnB,IAAwByB,iBAA5B,EAA+C;AAC3CC,kBAAAA,sBAAsB,CAAC5B,KAAD,EAAQc,QAAR,EAAkBa,iBAAlB,CAAtB;AACH,iBAFD,MAGK;AACD,wBAAMkB,cAAc,GAAG/C,gBAAgB,CAACC,OAAD,EAAUnB,MAAM,CAACkE,MAAP,CAAclE,MAAM,CAACkE,MAAP,CAAc,EAAd,EAAkB9C,KAAlB,CAAd,EAAwC;AAAEe,oBAAAA,UAAU,EAAED,QAAd;AAAwBF,oBAAAA,SAAS,EAAE,CAAC8B,EAAE,GAAG1C,KAAK,CAACY,SAAZ,MAA2B,IAA3B,IAAmC8B,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACK,KAAH,CAAS,CAACJ,EAAE,GAAG3C,KAAK,CAACY,SAAZ,MAA2B,IAA3B,IAAmC+B,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACK,OAAH,CAAWlC,QAAX,CAArE;AAA/F,mBAAxC,CAAV,EAAgPb,YAAhP,EAA8PC,cAA9P,EAA8QC,KAA9Q,EAAqRC,eAArR,EAAsSC,UAAtS,EACvC;AACA6B,kBAAAA,mBAAmB,CAACc,OAApB,CAA4BlC,QAA5B,CAFuC,EAEAP,MAFA,EAEQC,cAFR,CAAvC;AAGAJ,kBAAAA,eAAe,GAAGyC,cAAc,CAACzC,eAAjC;AACAH,kBAAAA,YAAY,GAAG4C,cAAc,CAAC5C,YAA9B;AACH;AACJ,eAnBD;AAoBH,aArBD,MAsBK;AACD2B,cAAAA,sBAAsB,CAAC5B,KAAD,EAAQA,KAAK,CAACe,UAAd,EAA0BY,iBAA1B,CAAtB;AACH;AACJ,WA3BD,MA4BK,IAAIzB,cAAc,KAAK,CAAC,GAAxB,EAA6B;AAC9B,gBAAIF,KAAK,CAACY,SAAV,EAAqB;AACjBZ,cAAAA,KAAK,CAACY,SAAN,CAAgBC,OAAhB,CAAyBC,QAAD,IAAc;AAClCc,gBAAAA,sBAAsB,CAAC5B,KAAD,EAAQc,QAAR,EAAkBa,iBAAlB,CAAtB;AACH,eAFD;AAGH,aAJD,MAKK;AACDC,cAAAA,sBAAsB,CAAC5B,KAAD,EAAQA,KAAK,CAACe,UAAd,EAA0BY,iBAA1B,CAAtB;AACH;AACJ,WATI,MAUA;AACD,kBAAMkB,cAAc,GAAG/C,gBAAgB,CAACC,OAAD,EAAUC,KAAV,EAAiBC,YAAjB,EAA+BC,cAA/B,EAA+CC,KAA/C,EAAsDC,eAAtD,EAAuEC,UAAvE,EAAmFC,QAAnF,EAA6FC,MAA7F,EAAqGC,cAArG,CAAvC;AACAJ,YAAAA,eAAe,GAAGyC,cAAc,CAACzC,eAAjC;AACAH,YAAAA,YAAY,GAAG4C,cAAc,CAAC5C,YAA9B;AACH;AACJ;AACJ,OA5DD;AA6DH;AACJ,GApED;AAqEA,SAAO;AACHyB,IAAAA,SAAS,EAAEnB,MADR;AAEHoB,IAAAA,iBAFG;AAGHvB,IAAAA;AAHG,GAAP;AAKH,CAvFD;;AAwFAtB,OAAO,CAACG,YAAR,GAAuBA,YAAvB;;AACA,MAAMD,iBAAiB,GAAIiE,IAAD,IAAU;AAChC,SAAQA,IAAI,KAAK9D,OAAO,CAAC+D,aAAR,CAAsBC,IAA/B,IACJF,IAAI,KAAK9D,OAAO,CAAC+D,aAAR,CAAsBE,GAD3B,IAEJH,IAAI,KAAK9D,OAAO,CAAC+D,aAAR,CAAsBG,UAFnC;AAGH,CAJD;;AAKAvE,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkIfIsDaysView = exports.getRowLayout = exports.DEFAULT_ROW_LAYOUT_RESULT = void 0;\nconst index_1 = require(\"../index\");\nconst constants_1 = require(\"../constants\");\nconst Helper_1 = require(\"./Helper\");\n/**\n * Find free slot in day column where to put event\n * @param indexes\n * @param maxEventsVisible\n */\nconst findFreeSlot = (indexes, maxEventsVisible) => {\n    let freeIndex;\n    if (!maxEventsVisible || maxEventsVisible <= 0) {\n        return -999;\n    }\n    for (let i = 0; i < maxEventsVisible + 1; i++) {\n        if (indexes.length === 0 || !indexes.includes(i)) {\n            freeIndex = i;\n            return freeIndex;\n        }\n    }\n    return -1;\n};\nconst addEventToResult = (usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents) => {\n    usedIDs.push(`${event.id}_${event.internalID}`);\n    if (event.daySpawns) {\n        event.daySpawns.forEach((daySpawn) => {\n            if (takenIndexes[daySpawn]) {\n                takenIndexes[daySpawn] = [\n                    ...takenIndexes[daySpawn],\n                    ...[offsetTopIndex],\n                ];\n            }\n            else {\n                takenIndexes[daySpawn] = [offsetTopIndex];\n            }\n        });\n    }\n    else {\n        if (takenIndexes[event.originDate]) {\n            takenIndexes[event.originDate] = [\n                ...takenIndexes[event.originDate],\n                ...[offsetTopIndex],\n            ];\n        }\n        else {\n            takenIndexes[event.originDate] = [offsetTopIndex];\n        }\n    }\n    // spawn width across all days\n    const eventWidth = event.daySpawns ? width * event.daySpawns.length : width;\n    const eventOffsetTop = 20 * offsetTopIndex;\n    if (isHeaderEvents && eventOffsetTop > headerOffsetTop) {\n        headerOffsetTop = eventOffsetTop;\n    }\n    const data = {\n        event,\n        width: Math.round(eventWidth - tableSpace),\n        offsetLeft: dayIndex * width + 2,\n        offsetTop: constants_1.getEventHeight(isHeaderEvents) * offsetTopIndex + offsetTopIndex,\n        height: constants_1.getEventHeight(isHeaderEvents),\n        zIndex: 2,\n    };\n    result.push(data);\n    return {\n        headerOffsetTop,\n        takenIndexes,\n    };\n};\nexports.DEFAULT_ROW_LAYOUT_RESULT = {\n    positions: [],\n    overflowingEvents: [],\n    headerOffsetTop: 0,\n};\nconst addToOverflowingEvents = (event, date, overflowingEvents) => {\n    if (overflowingEvents[date]) {\n        overflowingEvents[date] = [...overflowingEvents[date], event];\n    }\n    else {\n        overflowingEvents[date] = [event];\n    }\n};\n/**\n * Use for month view and header events\n * @param events\n * @param width\n * @param calendarDays\n * @param timezone\n * @param maxEventsVisible\n * @param isHeaderEvents\n * @param overflowingEvents\n */\nconst getRowLayout = (events, width, calendarDays, timezone, maxEventsVisible, isHeaderEvents, overflowingEvents) => {\n    // store biggest offset top for day view header events\n    let headerOffsetTop = 0;\n    const tableSpace = (width / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;\n    const result = [];\n    if (!events) {\n        return exports.DEFAULT_ROW_LAYOUT_RESULT;\n    }\n    // prevent adding duplicates from multi-day clones\n    const usedIDs = [];\n    // store taken indexes under date key\n    let takenIndexes = {};\n    const calendarDaysDateKey = calendarDays.map((day) => Helper_1.formatToDateKey(day, timezone));\n    calendarDays.forEach((day, dayIndex) => {\n        const dateKey = Helper_1.formatToDateKey(day, timezone);\n        // get only events for this day\n        const dayEvents = events[dateKey];\n        let eventRealIndex = 0; // use basic index for events with free slots\n        if (dayEvents) {\n            dayEvents.forEach((event) => {\n                const takenSlots = takenIndexes[event.originDate];\n                // find free slot\n                let offsetTopIndex = takenSlots\n                    ? findFreeSlot(takenSlots, maxEventsVisible)\n                    : eventRealIndex;\n                if (!usedIDs.includes(event.id)) {\n                    //\n                    if (!maxEventsVisible ||\n                        maxEventsVisible <= 0 ||\n                        eventRealIndex >= maxEventsVisible ||\n                        offsetTopIndex >= maxEventsVisible) {\n                        offsetTopIndex = -999;\n                    }\n                    eventRealIndex += 1;\n                    // check for overflowing events\n                    if (offsetTopIndex === -1 && overflowingEvents) {\n                        // save all clones to overflown array\n                        if (event.daySpawns) {\n                            event.daySpawns.forEach((daySpawn) => {\n                                var _a, _b;\n                                // check if we can fit spawn to column\n                                const takenSlotsSpawn = takenIndexes[daySpawn];\n                                // find free slot\n                                offsetTopIndex = takenSlotsSpawn\n                                    ? findFreeSlot(takenSlotsSpawn, maxEventsVisible)\n                                    : 0; // we can use 0 top index as either next day wasn't\n                                // iterated yet or takenSlotsSpawn exists for that column\n                                if (offsetTopIndex <= -1 && overflowingEvents) {\n                                    addToOverflowingEvents(event, daySpawn, overflowingEvents);\n                                }\n                                else {\n                                    const eventAddResult = addEventToResult(usedIDs, Object.assign(Object.assign({}, event), { originDate: daySpawn, daySpawns: (_a = event.daySpawns) === null || _a === void 0 ? void 0 : _a.slice((_b = event.daySpawns) === null || _b === void 0 ? void 0 : _b.indexOf(daySpawn)) }), takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, \n                                    // adjust date index for daySpawn\n                                    calendarDaysDateKey.indexOf(daySpawn), result, isHeaderEvents);\n                                    headerOffsetTop = eventAddResult.headerOffsetTop;\n                                    takenIndexes = eventAddResult.takenIndexes;\n                                }\n                            });\n                        }\n                        else {\n                            addToOverflowingEvents(event, event.originDate, overflowingEvents);\n                        }\n                    }\n                    else if (offsetTopIndex === -999) {\n                        if (event.daySpawns) {\n                            event.daySpawns.forEach((daySpawn) => {\n                                addToOverflowingEvents(event, daySpawn, overflowingEvents);\n                            });\n                        }\n                        else {\n                            addToOverflowingEvents(event, event.originDate, overflowingEvents);\n                        }\n                    }\n                    else {\n                        const eventAddResult = addEventToResult(usedIDs, event, takenIndexes, offsetTopIndex, width, headerOffsetTop, tableSpace, dayIndex, result, isHeaderEvents);\n                        headerOffsetTop = eventAddResult.headerOffsetTop;\n                        takenIndexes = eventAddResult.takenIndexes;\n                    }\n                }\n            });\n        }\n    });\n    return {\n        positions: result,\n        overflowingEvents,\n        headerOffsetTop,\n    };\n};\nexports.getRowLayout = getRowLayout;\nconst checkIfIsDaysView = (view) => {\n    return (view === index_1.CALENDAR_VIEW.WEEK ||\n        view === index_1.CALENDAR_VIEW.DAY ||\n        view === index_1.CALENDAR_VIEW.THREE_DAYS);\n};\nexports.checkIfIsDaysView = checkIfIsDaysView;\n"]},"metadata":{},"sourceType":"script"}