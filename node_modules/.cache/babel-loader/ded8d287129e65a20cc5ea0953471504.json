{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDaysViewLayout = void 0;\n\nconst index_1 = require(\"../index\");\n\nconst constants_1 = require(\"../constants\");\n\nconst headerViewHelper_1 = require(\"../utils/headerViewHelper\");\n\nconst Helper_1 = require(\"../utils/Helper\");\n\nconst KalendHelper_1 = require(\"../utils/KalendHelper\");\n\nconst allDayEvents_1 = require(\"../utils/allDayEvents\");\n\nconst LuxonHelper_1 = require(\"../utils/LuxonHelper\");\n\nconst checkOverlappingYCoordinates = (item, refFirstCoordinate, refLastCoordinate) => {\n  if (item.offsetTop >= refFirstCoordinate && item.offsetTop <= refLastCoordinate || refLastCoordinate >= item.offsetTop && refLastCoordinate <= item.offsetTop || refFirstCoordinate >= item.offsetTop && refFirstCoordinate <= item.itemLastCoordinate || item.offsetTop <= refFirstCoordinate && item.itemLastCoordinate >= refLastCoordinate) {\n    return true;\n  }\n\n  return false;\n};\n\nconst calculateNormalEventPositions = (events, baseWidth, config, selectedView, dateKey) => {\n  const result = [];\n\n  if (!events) {\n    return result;\n  }\n\n  const tableWidth = baseWidth / KalendHelper_1.getDaysNum(selectedView);\n  const tableSpace = tableWidth / 100 * constants_1.EVENT_TABLE_DELIMITER_SPACE; // sort by event start\n\n  let sortedEvents = events.sort((a, b) => {\n    return a.startAt.localeCompare(b.startAt);\n  }); // add offset top and height\n  // TODO can be moved to any iteration before to optimize more\n\n  sortedEvents = sortedEvents.map(event => {\n    const offsetTop = // @ts-ignore\n    LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt, config.timezone).diff(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt, config.timezone).set({\n      hour: 0,\n      minute: 0,\n      second: 0\n    }), 'minutes').toObject().minutes / (60 / config.hourHeight); // adjust based on hour column height\n\n    const eventHeight = // @ts-ignore\n    LuxonHelper_1.parseToDateTime(event.endAt, event.timezoneStartAt).diff(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt), 'minutes').toObject().minutes / (60 / config.hourHeight); // adjust based on hour column height\n\n    return {\n      event,\n      offsetTop,\n      eventHeight,\n      itemLastCoordinate: offsetTop + eventHeight\n    };\n  });\n  const layoutGroups = []; // now calculate layout for each overlapping group\n\n  let currentGroup = [];\n  let isFirst = true;\n  let groupFirstCoordinate = 0;\n  let groupLastCoordinate = 0;\n  let currentGroupID = 0;\n  const usedGroupIDs = [];\n  sortedEvents.forEach(item => {\n    if (isFirst) {\n      currentGroup.push(item);\n\n      if (sortedEvents.length === 1) {\n        layoutGroups.push(currentGroup);\n        currentGroup = [];\n      }\n\n      groupFirstCoordinate = item.offsetTop;\n      groupLastCoordinate = item.itemLastCoordinate;\n      isFirst = false;\n    } else {\n      // check if next event is inside current group coordinates\n      const isOverlapping = checkOverlappingYCoordinates(item, groupFirstCoordinate, groupLastCoordinate); // add to group\n\n      if (isOverlapping) {\n        currentGroup.push(item); // TODO this should never occur because of sorting\n\n        if (item.offsetTop > groupFirstCoordinate) {\n          groupFirstCoordinate = item.offsetTop;\n        }\n\n        if (item.itemLastCoordinate > groupLastCoordinate) {\n          groupLastCoordinate = item.itemLastCoordinate;\n        }\n      } else {\n        // we have new group of events\n        // store previous group\n        layoutGroups.push(currentGroup);\n        usedGroupIDs.push(String(currentGroupID));\n        currentGroupID += 1;\n        currentGroup = [];\n        currentGroup.push(item);\n        groupFirstCoordinate = item.offsetTop;\n        groupLastCoordinate = item.itemLastCoordinate;\n      }\n    }\n  });\n\n  if (!usedGroupIDs.includes(String(currentGroupID))) {\n    if (currentGroup.length > 0) {\n      layoutGroups.push(currentGroup);\n    }\n  } // now adjust layout for each event\n\n\n  layoutGroups.forEach(groups => {\n    const count = groups.length;\n    const eventWidth = tableWidth / count; //\n    // const partialResult: any[] = result.map((item: any) => {\n    //   // full event width\n    //   if (item.meta?.isFullWidth) {\n    //     return {\n    //       ...item,\n    //       width: Math.round(item.width - tableSpace), // add some padding,\n    //     };\n    //   } else if (item.offsetLeft > 0) {\n    //     return {\n    //       ...item,\n    //       width: Math.round(item.width),\n    //       offsetLeft: item.offsetLeft - tableSpace,\n    //       zIndex: item.zIndex ? item.zIndex + 2 : 2,\n    //     };\n    //   } else {\n    //     return { ...item, width: Math.round(item.width) };\n    //   }\n    // });\n\n    groups.forEach((groupItem, index) => {\n      const isFullWidth = eventWidth === tableWidth;\n      const offsetLeft = eventWidth * index;\n      result.push({\n        dateKey,\n        event: groupItem.event,\n        height: groupItem.eventHeight < constants_1.EVENT_MIN_HEIGHT ? constants_1.EVENT_MIN_HEIGHT : groupItem.eventHeight,\n        width: isFullWidth ? eventWidth - tableSpace : eventWidth,\n        // some padding\n        offsetLeft: offsetLeft > 0 ? offsetLeft - tableSpace : offsetLeft,\n        offsetTop: groupItem.offsetTop,\n        zIndex: 2 + index,\n        meta: {\n          isFullWidth: eventWidth === 1,\n          showTime: eventWidth >= constants_1.SHOW_TIME_THRESHOLD && groupItem.eventHeight >= constants_1.SHOW_TIME_THRESHOLD,\n          centerText: groupItem.eventHeight <= constants_1.SHOW_TIME_THRESHOLD\n        }\n      });\n    });\n  });\n  return result;\n};\n\nconst calculateDaysViewLayout = (calendarDays, events, baseWidth, config, selectedView) => {\n  const result = {};\n  calendarDays.forEach(calendarDay => {\n    const formattedDayString = Helper_1.formatToDateKey(calendarDay, config.timezone);\n    const dayEvents = events[formattedDayString];\n    const positions = calculateNormalEventPositions(dayEvents, baseWidth, config, selectedView, formattedDayString);\n    result[formattedDayString] = positions;\n  });\n  return result;\n};\n\nconst getDaysViewLayout = (events, calendarDays, config, width, selectedView, isMobile) => {\n  // add allDay flag to events\n  const eventsParsed = allDayEvents_1.parseAllDayEventsArray(events, config.timezone); // filter to header and normal events\n\n  const headerEvents = {};\n  const headerEventsTemp = [];\n  const normalEvents = {};\n  eventsParsed.forEach(event => {\n    const startDate = LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt || config.timezone);\n    const key = Helper_1.formatToDateKey(startDate, config.timezone);\n\n    if (event.allDay) {\n      headerEventsTemp.push(event);\n\n      if (headerEvents[key]) {\n        headerEvents[key] = [...headerEvents[key], ...[event]];\n      } else {\n        headerEvents[key] = [event];\n      }\n    } else {\n      if (normalEvents[key]) {\n        normalEvents[key] = [...normalEvents[key], ...[event]];\n      } else {\n        normalEvents[key] = [event];\n      }\n    }\n  });\n  const headerPositions = headerViewHelper_1.calculatePositionForHeaderEvents(headerEventsTemp, KalendHelper_1.getCorrectWidth(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), calendarDays, config, selectedView); // TODO filter header and normal events before\n\n  const normalPositions = calculateDaysViewLayout(calendarDays, normalEvents, KalendHelper_1.getCorrectWidth(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), config, selectedView);\n  return {\n    normalPositions,\n    headerPositions\n  };\n};\n\nexports.getDaysViewLayout = getDaysViewLayout;","map":{"version":3,"sources":["C:/Users/deval/Desktop/JSX/calendar2.0/node_modules/kalend-layout/views/daysView.js"],"names":["Object","defineProperty","exports","value","getDaysViewLayout","index_1","require","constants_1","headerViewHelper_1","Helper_1","KalendHelper_1","allDayEvents_1","LuxonHelper_1","checkOverlappingYCoordinates","item","refFirstCoordinate","refLastCoordinate","offsetTop","itemLastCoordinate","calculateNormalEventPositions","events","baseWidth","config","selectedView","dateKey","result","tableWidth","getDaysNum","tableSpace","EVENT_TABLE_DELIMITER_SPACE","sortedEvents","sort","a","b","startAt","localeCompare","map","event","parseToDateTime","timezoneStartAt","timezone","diff","set","hour","minute","second","toObject","minutes","hourHeight","eventHeight","endAt","layoutGroups","currentGroup","isFirst","groupFirstCoordinate","groupLastCoordinate","currentGroupID","usedGroupIDs","forEach","push","length","isOverlapping","String","includes","groups","count","eventWidth","groupItem","index","isFullWidth","offsetLeft","height","EVENT_MIN_HEIGHT","width","zIndex","meta","showTime","SHOW_TIME_THRESHOLD","centerText","calculateDaysViewLayout","calendarDays","calendarDay","formattedDayString","formatToDateKey","dayEvents","positions","isMobile","eventsParsed","parseAllDayEventsArray","headerEvents","headerEventsTemp","normalEvents","startDate","key","allDay","headerPositions","calculatePositionForHeaderEvents","getCorrectWidth","CALENDAR_VIEW","WEEK","normalPositions"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDaysViewLayout = void 0;\nconst index_1 = require(\"../index\");\nconst constants_1 = require(\"../constants\");\nconst headerViewHelper_1 = require(\"../utils/headerViewHelper\");\nconst Helper_1 = require(\"../utils/Helper\");\nconst KalendHelper_1 = require(\"../utils/KalendHelper\");\nconst allDayEvents_1 = require(\"../utils/allDayEvents\");\nconst LuxonHelper_1 = require(\"../utils/LuxonHelper\");\nconst checkOverlappingYCoordinates = (item, refFirstCoordinate, refLastCoordinate) => {\n    if ((item.offsetTop >= refFirstCoordinate &&\n        item.offsetTop <= refLastCoordinate) ||\n        (refLastCoordinate >= item.offsetTop &&\n            refLastCoordinate <= item.offsetTop) ||\n        (refFirstCoordinate >= item.offsetTop &&\n            refFirstCoordinate <= item.itemLastCoordinate) ||\n        (item.offsetTop <= refFirstCoordinate &&\n            item.itemLastCoordinate >= refLastCoordinate)) {\n        return true;\n    }\n    return false;\n};\nconst calculateNormalEventPositions = (events, baseWidth, config, selectedView, dateKey) => {\n    const result = [];\n    if (!events) {\n        return result;\n    }\n    const tableWidth = baseWidth / KalendHelper_1.getDaysNum(selectedView);\n    const tableSpace = (tableWidth / 100) * constants_1.EVENT_TABLE_DELIMITER_SPACE;\n    // sort by event start\n    let sortedEvents = events.sort((a, b) => {\n        return a.startAt.localeCompare(b.startAt);\n    });\n    // add offset top and height\n    // TODO can be moved to any iteration before to optimize more\n    sortedEvents = sortedEvents.map((event) => {\n        const offsetTop = \n        // @ts-ignore\n        LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt, config.timezone)\n            .diff(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt, config.timezone).set({\n            hour: 0,\n            minute: 0,\n            second: 0,\n        }), 'minutes')\n            .toObject().minutes /\n            (60 / config.hourHeight); // adjust based on hour column height\n        const eventHeight = \n        // @ts-ignore\n        LuxonHelper_1.parseToDateTime(event.endAt, event.timezoneStartAt)\n            .diff(LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt), 'minutes')\n            .toObject().minutes /\n            (60 / config.hourHeight); // adjust based on hour column height\n        return {\n            event,\n            offsetTop,\n            eventHeight,\n            itemLastCoordinate: offsetTop + eventHeight,\n        };\n    });\n    const layoutGroups = [];\n    // now calculate layout for each overlapping group\n    let currentGroup = [];\n    let isFirst = true;\n    let groupFirstCoordinate = 0;\n    let groupLastCoordinate = 0;\n    let currentGroupID = 0;\n    const usedGroupIDs = [];\n    sortedEvents.forEach((item) => {\n        if (isFirst) {\n            currentGroup.push(item);\n            if (sortedEvents.length === 1) {\n                layoutGroups.push(currentGroup);\n                currentGroup = [];\n            }\n            groupFirstCoordinate = item.offsetTop;\n            groupLastCoordinate = item.itemLastCoordinate;\n            isFirst = false;\n        }\n        else {\n            // check if next event is inside current group coordinates\n            const isOverlapping = checkOverlappingYCoordinates(item, groupFirstCoordinate, groupLastCoordinate);\n            // add to group\n            if (isOverlapping) {\n                currentGroup.push(item);\n                // TODO this should never occur because of sorting\n                if (item.offsetTop > groupFirstCoordinate) {\n                    groupFirstCoordinate = item.offsetTop;\n                }\n                if (item.itemLastCoordinate > groupLastCoordinate) {\n                    groupLastCoordinate = item.itemLastCoordinate;\n                }\n            }\n            else {\n                // we have new group of events\n                // store previous group\n                layoutGroups.push(currentGroup);\n                usedGroupIDs.push(String(currentGroupID));\n                currentGroupID += 1;\n                currentGroup = [];\n                currentGroup.push(item);\n                groupFirstCoordinate = item.offsetTop;\n                groupLastCoordinate = item.itemLastCoordinate;\n            }\n        }\n    });\n    if (!usedGroupIDs.includes(String(currentGroupID))) {\n        if (currentGroup.length > 0) {\n            layoutGroups.push(currentGroup);\n        }\n    }\n    // now adjust layout for each event\n    layoutGroups.forEach((groups) => {\n        const count = groups.length;\n        const eventWidth = tableWidth / count;\n        //\n        // const partialResult: any[] = result.map((item: any) => {\n        //   // full event width\n        //   if (item.meta?.isFullWidth) {\n        //     return {\n        //       ...item,\n        //       width: Math.round(item.width - tableSpace), // add some padding,\n        //     };\n        //   } else if (item.offsetLeft > 0) {\n        //     return {\n        //       ...item,\n        //       width: Math.round(item.width),\n        //       offsetLeft: item.offsetLeft - tableSpace,\n        //       zIndex: item.zIndex ? item.zIndex + 2 : 2,\n        //     };\n        //   } else {\n        //     return { ...item, width: Math.round(item.width) };\n        //   }\n        // });\n        groups.forEach((groupItem, index) => {\n            const isFullWidth = eventWidth === tableWidth;\n            const offsetLeft = eventWidth * index;\n            result.push({\n                dateKey,\n                event: groupItem.event,\n                height: groupItem.eventHeight < constants_1.EVENT_MIN_HEIGHT\n                    ? constants_1.EVENT_MIN_HEIGHT\n                    : groupItem.eventHeight,\n                width: isFullWidth ? eventWidth - tableSpace : eventWidth,\n                // some padding\n                offsetLeft: offsetLeft > 0 ? offsetLeft - tableSpace : offsetLeft,\n                offsetTop: groupItem.offsetTop,\n                zIndex: 2 + index,\n                meta: {\n                    isFullWidth: eventWidth === 1,\n                    showTime: eventWidth >= constants_1.SHOW_TIME_THRESHOLD &&\n                        groupItem.eventHeight >= constants_1.SHOW_TIME_THRESHOLD,\n                    centerText: groupItem.eventHeight <= constants_1.SHOW_TIME_THRESHOLD,\n                },\n            });\n        });\n    });\n    return result;\n};\nconst calculateDaysViewLayout = (calendarDays, events, baseWidth, config, selectedView) => {\n    const result = {};\n    calendarDays.forEach((calendarDay) => {\n        const formattedDayString = Helper_1.formatToDateKey(calendarDay, config.timezone);\n        const dayEvents = events[formattedDayString];\n        const positions = calculateNormalEventPositions(dayEvents, baseWidth, config, selectedView, formattedDayString);\n        result[formattedDayString] = positions;\n    });\n    return result;\n};\nconst getDaysViewLayout = (events, calendarDays, config, width, selectedView, isMobile) => {\n    // add allDay flag to events\n    const eventsParsed = allDayEvents_1.parseAllDayEventsArray(events, config.timezone);\n    // filter to header and normal events\n    const headerEvents = {};\n    const headerEventsTemp = [];\n    const normalEvents = {};\n    eventsParsed.forEach((event) => {\n        const startDate = LuxonHelper_1.parseToDateTime(event.startAt, event.timezoneStartAt || config.timezone);\n        const key = Helper_1.formatToDateKey(startDate, config.timezone);\n        if (event.allDay) {\n            headerEventsTemp.push(event);\n            if (headerEvents[key]) {\n                headerEvents[key] = [...headerEvents[key], ...[event]];\n            }\n            else {\n                headerEvents[key] = [event];\n            }\n        }\n        else {\n            if (normalEvents[key]) {\n                normalEvents[key] = [...normalEvents[key], ...[event]];\n            }\n            else {\n                normalEvents[key] = [event];\n            }\n        }\n    });\n    const headerPositions = headerViewHelper_1.calculatePositionForHeaderEvents(headerEventsTemp, KalendHelper_1.getCorrectWidth(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), calendarDays, config, selectedView);\n    // TODO filter header and normal events before\n    const normalPositions = calculateDaysViewLayout(calendarDays, normalEvents, KalendHelper_1.getCorrectWidth(width, isMobile || false, index_1.CALENDAR_VIEW.WEEK), config, selectedView);\n    return { normalPositions, headerPositions };\n};\nexports.getDaysViewLayout = getDaysViewLayout;\n"]},"metadata":{},"sourceType":"script"}